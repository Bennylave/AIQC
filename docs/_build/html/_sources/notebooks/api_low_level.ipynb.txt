{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Low-Level API"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Prerequisites"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you've already completed the instructions on the **Installation** page, then let's get started."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "import aiqc\n",
    "from aiqc import datum"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Ingest a `Dataset`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Object Relational Model (ORM)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "At the moment, AIQC supports the following types of Datasets:\n",
    "\n",
    "* Single-file tabular/ flat/ delimited datasets.\n",
    "* Multi-file image datasets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "End users only need to worry about passing the right inputs to the Dataset class, but there are a few objects doing the legwork beneath the hood:\n",
    "\n",
    "* `Dataset` ORM class with subclasses of either `Tabular` or `Image`.\n",
    "  * `File` ORM class one or more files with subclasses of either `Tabular` or `Image`.\n",
    "    * Dedicated `Tabular` and `Image` ORM classes for attributes specific to those data types (e.g. dtype mappings for flat files and colorscale for images)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> *Considering these types in the future:*\n",
    "> * *Sequence/ time series: multi-file tabular (e.g. 3D numpy, HDF5)*\n",
    "> * *Graph: multi-file nodes and multi-file edges (e.g. DGL)*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Persisting and Compressing Structured Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By default the actual bytes of the file are persisted to the SQLite `BlobField`. It gets gzip compressed, reducing the size by up to 90%. Maximum BlobField size is 2.147 GB, but once you factor in compression, your bottleneck is more likely to be memory beyond that size. The bytes themselves are Parquet (single-partitioned) because, using the PyArrow engine, it preserves every dtype except certain datetimes (which are honestly better off parsed into floats/ ordinal ints). Parquet is also integrated nicely into both Spark and Dask; frameworks for distributed, in-memory computation.\n",
    "\n",
    "Persisting the file ensures reproducibility by: (a) keeping the data packaged alongside the experiment, and (b) helping entry-level users move away from relying on mutable dataframes they have had in-memory for extended periods of time or floating around on shared file systems.\n",
    "\n",
    "> *However, we realize that a different approach will be required at scale, so the `source_path` of the file is recorded whenever possible. In the future we could just read the data from that path (e.g. NFS, RDBMS, HDFS, S3) if the BlobField is none. Or just switch our data fetching/ filtering to Dask because it uses the Pandas API and Parquet.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Data Sources"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can make a dataset from either:\n",
    "* `Dataset.Tabular`\n",
    "  * In-memory data structures (pandas dataframe, numpy array).\n",
    "  * Flat files (csv, tsv, parquet).\n",
    "    * Accepts urls.\n",
    "\n",
    "\n",
    "* `Dataset.Image`\n",
    "  * Any image file format that can be read by the Pillow library.\n",
    "    * Accepts urls."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Dataset.Tabular.from_pandas()`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = datum.to_pandas('iris.tsv')\n",
    "\n",
    "dataset = aiqc.Dataset.Tabular.from_pandas(\n",
    "\tdataframe = df\n",
    "    , name = 'tab separated plants'\n",
    "    , dtype = None #passed to pd.Dataframe(dtype)/ inferred\n",
    "    , column_names = None #passed to pd.Dataframe(columns)\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> Optionally, `dtype`, as seen in [`pandas.DataFrame.astype(dtype)`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.astype.html), can be specified as either a single type for all columns, or as a dictionary that maps a specific type to each column name. This encodes features for analysis. We read NumPy into Pandas before persisting it, so `columns` and `dtype` are read directly by `pd.DataFrame()`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Dataset.Tabular.from_numpy()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Must be a 2D NumPy N-Dimensional Array.\n",
    "\n",
    "> *In the future, we may add support for ingesting 3D arrays as multi-file sequences.*\n",
    "\n",
    "Regular *ndarrays* don't have column names, and I didn't like the API for *structured arrays* so you have to pass in columns names as a list. If you don't then column names will be numerically assigned in ascending order (zero-based index), but I didn't like the range object, so I stringified numerically assigned columns to string-based numbers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "arr =  df.to_numpy()\n",
    "cols = list(df.columns)\n",
    "\n",
    "dataset = aiqc.Dataset.from_numpy(\n",
    "\tndarray = arr\n",
    "    , name = None\n",
    "    , dtype = None #passed to pd.Dataframe(dtype)/ inferred \n",
    "    , column_names = cols #passed to pd.Dataframe(columns)\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Dataset.Tabular.from_path`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Intended for flat files, delimited text, and structured tabular data. It's read in via Pandas, so it supports URLs to raw data and bytes as well."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "file_path = datum.get_path('iris_10x.tsv')\n",
    "\n",
    "# We'll keep this larger dataset handy for `Foldset` creation later.\n",
    "big_dataset = aiqc.Dataset.Tabular.from_path(\n",
    "    file_path = file_path\n",
    "    , source_file_format = 'tsv'\n",
    "    , name = None\n",
    "    , dtype = None\n",
    "    , column_names = None\n",
    "    , skip_header_rows = 'infer' #passed to `pd.read_csv(header)`. Incompatible w Parquet.\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> If you leave `name` blank, it will default to a human-readble timestamp with the appropriate file extension (e.g. '2020_10_13-01_28_13_PM.tsv')."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Dataset.Image.from_urls()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "During ingestion, all image files must have the same `Image.mode` and `Image.size` according to the Pillow library.\n",
    "\n",
    "> https://pillow.readthedocs.io/en/stable/handbook/concepts.html"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Image datasets are somewhat multi-modal in that, in order to perform supervised learning, they require a loosely coupled `Dataset.Tabular` that contains their labels."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = datum.to_pandas(name='brain_tumor.csv')\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `['status']` column of this dataframe serves as the Label of that sample. We'll construct a `Dataset.Tabular` from this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tabular_dataset = aiqc.Dataset.Tabular.from_pandas(dataframe=df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tabular_label = tabular_dataset.make_label(columns=['status'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Meanwhile, the `['url']` column acts as a manifest in that it contains the URL of the image file for that sample, solely for the purposes of initial ingestion. We'll construct a `Dataset.Image` from this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "image_urls = datum.get_remote_urls(manifest_name='brain_tumor.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "image_dataset = aiqc.Dataset.Image.from_urls(urls=image_urls)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "image_featureset = image_dataset.make_featureset()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Skipping forward a bit, we bring the heterogenous `Featureset` and `Label` together in the `Splitset`, and they can be used as normal. You can even construct a `Foldset` from this splitset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "image_splitset = image_featureset.make_splitset(\n",
    "    label_id = tabular_label.id\n",
    "    , size_test = 0.24\n",
    "    , size_validation = 0.12\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Dataset.Image.from_folder()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This method works in the same was as `from_urls` except that it accepts the path of a single, local directory rather than a list of urls to individual files.\n",
    "\n",
    "When reading in the image files in that folder, the fantastic `natsort.natsorted` library is used as the source of truth for the ordering of the files. When Python reads a list of files from a directory, it does so by insertion order rather than alpha-numerically. So make sure your tabular manifest has the same order.\n",
    "\n",
    "> https://natsort.readthedocs.io/en/master/api.html#natsort.natsorted"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reading Datasets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "All of the sample-related objects in the API have `to_numpy()` and `to_pandas()` methods that accept the following arguments:\n",
    "\n",
    "* `samples=[]` list of indeces to fetch.\n",
    "* `columns=[]` list of columns to fetch.\n",
    "* In some cases you can specify a `split`/ `fold` name.\n",
    "\n",
    "For structured data, since the `Dataset` itself is fairly removed from the `File.Tabular` it creates, you can get that tabular file with `Dataset.Tabular.get_main_tabular(dataset_id)` to inspect attributes like `dtypes` and `columns`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Later, we'll see how these arguments allow downstream objects like `Splitset` and `Foldset` to slice up the data."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Dataset.Tabular.to_pandas()`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>sepal_length</th>\n",
       "      <th>sepal_width</th>\n",
       "      <th>petal_length</th>\n",
       "      <th>petal_width</th>\n",
       "      <th>species</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>5.1</td>\n",
       "      <td>3.5</td>\n",
       "      <td>1.4</td>\n",
       "      <td>0.2</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>4.9</td>\n",
       "      <td>3.0</td>\n",
       "      <td>1.4</td>\n",
       "      <td>0.2</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>4.7</td>\n",
       "      <td>3.2</td>\n",
       "      <td>1.3</td>\n",
       "      <td>0.2</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>4.6</td>\n",
       "      <td>3.1</td>\n",
       "      <td>1.5</td>\n",
       "      <td>0.2</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>5.0</td>\n",
       "      <td>3.6</td>\n",
       "      <td>1.4</td>\n",
       "      <td>0.2</td>\n",
       "      <td>0.0</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   sepal_length  sepal_width  petal_length  petal_width  species\n",
       "0           5.1          3.5           1.4          0.2      0.0\n",
       "1           4.9          3.0           1.4          0.2      0.0\n",
       "2           4.7          3.2           1.3          0.2      0.0\n",
       "3           4.6          3.1           1.5          0.2      0.0\n",
       "4           5.0          3.6           1.4          0.2      0.0"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df = dataset.to_pandas()\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>sepal_length</th>\n",
       "      <th>sepal_width</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>5.1</td>\n",
       "      <td>3.5</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>13</th>\n",
       "      <td>4.3</td>\n",
       "      <td>3.0</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>29</th>\n",
       "      <td>4.7</td>\n",
       "      <td>3.2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>79</th>\n",
       "      <td>5.7</td>\n",
       "      <td>2.6</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    sepal_length  sepal_width\n",
       "0            5.1          3.5\n",
       "13           4.3          3.0\n",
       "29           4.7          3.2\n",
       "79           5.7          2.6"
      ]
     },
     "execution_count": 100,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df = aiqc.Dataset.to_pandas(\n",
    "    id = dataset.id \n",
    "    , samples = [0,13,29,79]\n",
    "    , columns = ['sepal_length', 'sepal_width']\n",
    ")\n",
    "df.tail()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Dataset.Tabular.to_numpy()`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1.4, 0.2],\n",
       "       [1.1, 0.1],\n",
       "       [1.6, 0.2],\n",
       "       [3.5, 1. ]])"
      ]
     },
     "execution_count": 99,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr = dataset.to_numpy(\n",
    "    samples = [0,13,29,79] \n",
    "    , columns = ['petal_length', 'petal_width']\n",
    ")\n",
    "arr[:4]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[5.1, 3.5, 1.4, 0.2, 0. ],\n",
       "       [4.9, 3. , 1.4, 0.2, 0. ],\n",
       "       [4.7, 3.2, 1.3, 0.2, 0. ],\n",
       "       [4.6, 3.1, 1.5, 0.2, 0. ]])"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "arr = aiqc.Dataset.to_numpy(id=dataset.id)\n",
    "arr[:4]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Dataset.Image.to_pillow()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Returns a list of `Pillow.Image`'s. You can actually see the image when you call them. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "images_pillow = image_dataset.to_pillow(samples=[1,2,3])\n",
    "images_pillow[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Dataset.Image.to_numpy()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This simply performs `np.array(Pillow.Image)`. Returns an N-dimensional array where the dimensions vary based on the `mode` aka colorscale of the image. For example, it returns '3D of 2Ds for black and white' or '4D of 3Ds for colored' - which would change the class of convultional layer you would use (`Conv1D`:`Conv3D`).\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "images_arr = image_dataset.to_numpy(samples=[1,2,3])\n",
    "images_arr.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> At the moment, we haven't found it necessary to provide a `to_pandas` method for images as they have no need for column names, the dtypes are homogenous, images are used as a whole so there is no filtering, Pandas isn't great with 3D data, and Pillow is integrated with NumPy."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Select the `Label` column(s)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ORM"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "From a Dataset, pick the column(s) that you want to predict/ train against. Creating a `Label` won't duplicate your data! It simply marks the Dataset `columns` to be used for supervised learning. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Later, we'll see that a `Label` triggers:\n",
    "* The `supervision` attribute of a `Splitset` to be either `'unsupervised'`/`'supervised'`.\n",
    "* Approval/ rejection of the `Algorithm.analysis_type`. For example, you wouldn't perform regression on a string label."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Part of the magic of this library is that it prevents you from making silly mistakes like these so that you aren't faced with some obscure NumPy/ Tensor, dtype/ dimensionality error on the nth layer of your neural network."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For categorical labels, but not for continuous/float labels, the `Label.unique_classes` are recorded."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Deriving Labels"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Keep the name of the label column handy as you may want to re-use it later when excluding features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "label_column = 'species'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Implicit IDs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "label = dataset.make_label(columns=[label_column])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> `columns=[label_column]` is a list in case users have already OneHotEncoded (OHEd) their label. If multiple columns are provided, then they must already be in OHE format. I'm not keen on supporting multi-label/ simultaneous analysis, but that could changed based on feasibility and user demand."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Explicit IDs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "label = aiqc.Label.from_dataset(\n",
    "\tdataset_id=1\n",
    "\t, columns=[label_column]\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reading Labels"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `Label` comes in handy when we need to fetch what is traditionally referred to as '*Y*' in tutorials. It also accepts a `samples` argument, so that `Splitset` can subset it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>species</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>145</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>146</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>147</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>148</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>149</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "     species\n",
       "145        2\n",
       "146        2\n",
       "147        2\n",
       "148        2\n",
       "149        2"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "label.to_pandas().tail()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0],\n",
       "       [0],\n",
       "       [1],\n",
       "       [1],\n",
       "       [2]])"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "label.to_numpy(samples=[0,33,66,99,132])[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Select the `Featureset` column(s)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ORM"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Creating a Featureset won't duplicate your data! It simply records the Dataset `columns` to be used as features during training. \n",
    "\n",
    "There are three ways to define which columns you want to use as features:\n",
    "\n",
    "- `exclude_columns=[]` e.g. use all columns except the label column.\n",
    "- `include_columns=[]` e.g. only use these columns that I think are informative.\n",
    "- Leave both of the above blank and all columns will be used (e.g. images or unsupervised leanring)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For structured data, since the Featureset is far removed from the `File.Tabular` that it is derived from, there is a `Featureset.get_dtypes()` method. This will come in handy when we are selecting dtypes/columns to include/ exclude in our `Featurecoder`(s)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Deriving Labels"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Via `include_columns=[]`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "include_columns = [\n",
    "    'sepal_length',\n",
    "    'petal_length',\n",
    "    'petal_width'\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "featureset = dataset.make_featureset(include_columns=include_columns)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Via `exclude_columns=[]`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "featureset = dataset.make_featureset(exclude_columns=[label_column])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['sepal_length', 'petal_length', 'petal_width']"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "featureset.columns"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Either way, any excluded columns will be recorded since they are used for dropping."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['sepal_width', 'species']"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "featureset.columns_excluded"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again, for images, just perform `Dataset.Image.make_featureset()` since you'll likely want to include all pixels and your label column is in a separate, coupled Dataset."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reading Featuresets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[5.1, 1.4, 0.2],\n",
       "       [4.9, 1.4, 0.2],\n",
       "       [4.7, 1.3, 0.2],\n",
       "       [4.6, 1.5, 0.2]])"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "featureset.to_numpy()[:4]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>sepal_length</th>\n",
       "      <th>petal_length</th>\n",
       "      <th>petal_width</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>5.1</td>\n",
       "      <td>1.4</td>\n",
       "      <td>0.2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>16</th>\n",
       "      <td>5.4</td>\n",
       "      <td>1.3</td>\n",
       "      <td>0.4</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>32</th>\n",
       "      <td>5.2</td>\n",
       "      <td>1.5</td>\n",
       "      <td>0.1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>64</th>\n",
       "      <td>5.6</td>\n",
       "      <td>3.6</td>\n",
       "      <td>1.3</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    sepal_length  petal_length  petal_width\n",
       "0            5.1           1.4          0.2\n",
       "16           5.4           1.3          0.4\n",
       "32           5.2           1.5          0.1\n",
       "64           5.6           3.6          1.3"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "featureset.to_pandas(samples=[0,16,32,64]).tail()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Slice samples with a `Splitset`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A `Splitset` divides a the samples of the Dataset into the following *splits* in the table below. It is the central object of the data preparation side of the ORM in that it touches `Label`, `Featureset`, `Foldset`, and `Encoderset`. It is the only mandatory data preparation object required by the training `Batch`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Both contiuous and categorical `Labels` are automatically stratified."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "| Split                 | Description                                                                                                                                                                                             |\n",
    "|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n",
    "| train                 | The samples that the model will be trained upon. <br/>Later, we’ll see how we can make *cross-folds from our training split*. <br/>Unsupervised learning will only have a training split.                 |\n",
    "| validation (optional) | The samples used for training evaluation. <br/>Ensures that the test set is not revealed to the model during training.                                                                                  |\n",
    "| test (optional)       | The samples the model has never seen during training. <br/>Used to assess how well the model will perform on unobserved, natural data when it is applied in the real world aka how generalizable it is. |"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again, creating a Splitset won't duplicate your data. It simply denotes the sample indeces (aka rows) to be used in the splits that you specify!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Split Strategies"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### a) Default supervised 70-30 split."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you only provide a Label, then 70:30 train:test splits will be generated."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset = featureset.make_splitset(label_id=label.id)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### b) Specifying test size."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset = featureset.make_splitset(\n",
    "\tlabel_id = label.id\n",
    "\t, size_test = 0.30\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### c) Specifying validation size."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset = featureset.make_splitset(\n",
    "\tlabel_id = label.id\n",
    "\t, size_test = 0.20\n",
    "\t, size_validation = 0.12\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### d) Taking the whole dataset as a training split."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset_unsupervised = featureset.make_splitset()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> Label-based stratification is used to ensure equally distributed label classes for both categorical and continuous data.\n",
    ">\n",
    "> If you want more control over stratification of continuous splits, specify the number of `continuous_bin_count` for grouping."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### e) Stratification of continuous labels."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "All splits are stratified by default in that they contain similar distributions of unique label classes so that each split is a statistically accurate representation of the population as a whole.\n",
    "\n",
    "In order to support this process for continuous labels, binning/ discretization is utilized. For example, if 4 bins are used, values from *0.0 to 1.0* would be binned as *[0.0-0.25, 0.25-0.50, 0.50-0.75, 0.75-1.0]*. This is controlled by the `make_splitset(bin_count:int)` argument. \n",
    "\n",
    "> Reference the handy `Pandas.qcut()`  and the source code `pd.qcut(x=array_to_bin, q=bin_count, labels=False, duplicates='drop')` for more detail."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reading Splitsets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset.samples.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`.keys()` of 1st layer are referred to as \"split_name\" in the source code: e.g. 'train' as well as, optionally, 'validation' and 'test'.\n",
    "  \n",
    "`Splitset.samples` on disk:\n",
    "```\n",
    " {\n",
    "     'train': [<sample_indeces>],\n",
    "     'validation': [<sample_indeces>],\n",
    "     'test': [<sample_indeces>]\n",
    " }\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can also verify the actual size of your splits."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'validation': {'percent': 0.12, 'count': 18},\n",
       " 'test': {'percent': 0.2, 'count': 30},\n",
       " 'train': {'percent': 0.68, 'count': 102}}"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "splitset.sizes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The main attribute of the splitset is the `samples` dictionary. Again, on-disk this only contains sample indeces. The dictionary is structured like so:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Splitset.to_numpy()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When fetched to memory, the `.keys()` of the 2nd layer are: 'features' and, optionally, 'labels'.\n",
    "\n",
    "Note that if you do not specified neither a `size_validation` nor `size_test`, then your dictionary will contain neither a `['validation']` nor `['test']` split."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[4.9, 4.5, 1.7],\n",
       "       [6.4, 5.3, 1.9],\n",
       "       [5.8, 5.1, 1.9],\n",
       "       [4.8, 1.6, 0.2]])"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "splitset.to_numpy()['train']['features'][:4]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Splitset.to_pandas()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Getting more fine-tuned, both the numpy and pandas methods support a few optional filters for the sake of memory-efficiency when fetching larger splits."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For example, imagine you are fetching data to specifically encode the only float column in the featureset of the test split. You don't need the labels and you don't need the other columns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "splitset.to_pandas(\n",
    "\tsplits = ['test']\n",
    "\t, include_label = False\n",
    "\t, include_featureset = True\n",
    "\t, feature_columns = ['sepal_width']\n",
    ")['test']['features'].head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Optionally, create a `Foldset` for cross-validation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ORM"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Reference the [scikit-learn documentation](https://scikit-learn.org/stable/modules/cross_validation.html) to learn more about folding.*\n",
    "\n",
    "![Cross Folds](../images/cross_fold.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We refer to the left out fold (blue) as the `fold_validation` and the remaining training data as the `folds_train_combined` (green)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> *In the future, we may introduce more folding `strategies` aside from leave-one-out.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Fold` objects"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For the sake of determining which samples get trained upon, the only thing that matters is the slice of data that gets left out."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> Tip - DO NOT use a `Foldset` unless your *(total sample count / fold_count)* still gives you an accurate representation of your sample population. If you are ignoring that advice and stretching to perform cross-validation, then at least ensure that *(total sample count / fold_count)* is evenly divisible. Both of these tips help avoid poorly stratified/ undersized folds that perform either too well (only most common label class present) or poorly (handful of samples and a few inaccurate prediction on a normally good model).\n",
    ">\n",
    "> Tip - The sample indeces of the validation fold are not discarded. In fact, `fold_validation` can actually be used alongside a split `validation` for double validation 🤘. However, it's more sensible to skip the validation split when cross-validating because you'll want each `fold_validation` to be as large (representative of the population) as possible. Folds naturally have fewer samples, so a handful of incorrect predictions have the potential to offset your aggregate metrics.\n",
    "> \n",
    "> Candidly, if you've ever performed cross-validation manually, let alone systematically, you'll know that, barring stratification of continuous labels, it's easy enough to construct the folds, but then it's a pain to generate performance metrics (e.g. `zero_division`, absent OHE classes) due to the absence of outlying classes and bins. Time has been invested to handle these scenarios elegantly so that folds can be treated as first-class-citizens alongside splits. That being said, if you try to do something undersized like \"150 samples in their dataset and a `fold_count` > 3 with `unique_classes` > 4,\" then you may run into edge cases."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similar to `Splitset.samples`, there is a `Fold.samples` dictionary of sample indeces with the following `.keys()`:\n",
    "* `samples['folds_train_combined']` - all the included folds.\n",
    "* `samples['fold_validation']` - the fold that got left out."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![cross fold objects](../images/cross_fold_objects.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Deriving Foldsets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "big_label = big_dataset.make_label(columns=[label_column])\n",
    "big_fset = big_dataset.make_featureset(exclude_columns=[label_column])\n",
    "big_splits = big_fset.make_splitset(\n",
    "\tlabel_id = big_label.id\n",
    "\t, size_test = 0.30\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we are ready to generate 5 `Fold` objects that belong to the `Foldset`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "foldset = big_splits.make_foldset(fold_count=5, bin_count=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<Fold: 1>, <Fold: 2>, <Fold: 3>, <Fold: 4>, <Fold: 5>]"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(foldset.folds)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reading Foldsets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Sample indeces of each Fold:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[0, 1, 2, 4, 5, 7, 9, 11, 12, 13]"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "foldset.folds[0].samples['folds_train_combined'][:10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[3, 6, 8, 10, 21, 29, 32, 33, 38, 46]"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "foldset.folds[0].samples['fold_validation'][:10]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Foldset.to_numpy()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In order to reduce memory footprint the `to_numpy()` and `to_pandas()` methods introduce the `fold_index` argument."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If no fold_index is specified, then it will fetch all folds and give each fold a numeric key according to its index."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "jupyter": {
     "outputs_hidden": true
    }
   },
   "source": [
    "So you need to specify the `fold_index` as the first key when accessing the dictionary."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[4.6, 3.1, 1.5, 0.2],\n",
       "       [4.6, 3.4, 1.4, 0.3],\n",
       "       [4.4, 2.9, 1.4, 0.2],\n",
       "       [5.4, 3.7, 1.5, 0.2]])"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "foldset.to_numpy(fold_index=0)[0]['fold_validation']['features'][:4]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Foldset.to_pandas()`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similar to `splitset.to_numpy(splits:list)`, the `foldset.to_numpy(fold_names:list)` argument allows you to pluck the `['folds_train_combined]` and `['fold_validation]` slices. Just make sure you remember to specific all 3 levels of keys when accessing the result."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>species</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>1044</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1046</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1047</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1048</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1049</th>\n",
       "      <td>2</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      species\n",
       "1044        2\n",
       "1046        2\n",
       "1047        2\n",
       "1048        2\n",
       "1049        2"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "foldset.to_pandas(\n",
    "    fold_index = 0\n",
    "\t, fold_names = ['folds_train_combined']\n",
    "\t, include_label = True\n",
    "\t, include_featureset = False\n",
    "\t, feature_columns = [label_column]\n",
    ")[0]['folds_train_combined']['labels'].tail()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Optionally, stage an `Encoderset` for encoding."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Background"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Certain algorithms either (a) require features and/ or labels formatted a certain way, or (b) perform MUCH better when their values are normalized. For example:\n",
    "\n",
    "* Converting ordinal or categorical string data `[dog, cat, fish]` into one-hot encoded format `[[1,0,0][0,1,0][0,0,1]]`.\n",
    "* Scaling continuous features from (-1 to 1) or (0.0 to 1.0). Or transforming them to resemble a more Gaussian distribution.\n",
    "\n",
    "There are two phases of encoding:\n",
    "1. `fit` - where the encoder learns about the values of the samples made available to it. Ideally, you only want to `fit` aka learn from your training split so that you are not *\"leaking\"* information from your validation and test spits into your encoder!\n",
    "2. `transform` - where the encoder transforms all of the samples in the population.\n",
    "\n",
    "AIQC has solved the following challenges that encoding brings to light:\n",
    "* How does one dynamically `fit` on only the training samples in advanced scenarios like cross-validation where a different fold is used for validation each time?\n",
    "* For certain encoders, especially categorical ones, there is arguably no leakage. If an encoder is arbitrarilly assigning values/ tags to a sample through a process that is not aggregate-informed, then the information that is reveal to the `fit` is largely irrelevant. As an analogy, if we are examining swan color and all of a sudden there is a black swan... it's clearly not white, so slap a non-white label on it and move on. In fact, the prediction process and performance metric calucatlion may fail if it doesn't know how to handle the previously unseen category.\n",
    "* Certain encoders only accept certain dtypes. Certain encoders only accept certain dimensionality (e.g. 1D, 2D, 3D) or shape patterns (odd-by-odd square). Unfortunately, there is not much uniformity here.\n",
    "* Certain encoders output extraneous objects that don't work with deep learning libraries.\n",
    "\n",
    "> *For now, only `sklearn.preprocessing` methods are supported. That may change as we add support for more low-level tensor-based frameworks like PyTorch.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Keeping this in mind, we create an `Encoderset` for our `Splitset`. We can attach a `Labelcoder` and/ or `Featurecoder`(s)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "encoderset = splitset.make_encoderset()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And then import any scikit-learn encoders that you need. AIQC only supports the uppercase methods (e.g. `RobustScaler`, but not `robust_scale`) because the lowercase methods do not separate the `fit` and `transform` steps. FYI, most of the uppercase methods have a combined `fit_transform` method if you need them. \n",
    "\n",
    "> https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.preprocessing import *"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Optionally, set a single `Labelcoder`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Background"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The simplistic `Labelcoder` is a good warmup for the moe advanced `Featurecoder`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Of course, you cannot encode Labels if your `Splitset` does not have labels in the first place."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The process is straightforward. You provide an instantiated encoder [e.g. `StandardScaler()` not `StandardScaler`], and then AIQC will:\n",
    "* Verify that the encoder works with your `Label`'s dtype, sample values, and figure out what dimensionality it needs in order to succeed.\n",
    "* Validate the attributes of your encoder to smooth out any common errors they would cause.\n",
    "* Determine whether the encoder should be `fit` either (a) exclusively on the train split, or (b) if it is not prone to leakage, inclusively on the entire dataset thereby reducing the chance of errors arising."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "labelcoder = encoderset.make_labelcoder(\n",
    "    sklearn_preprocess = OneHotEncoder(sparse=False)\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. Optionally, determine a sequence of `Featurecoder`(s)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Background"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `Featurecoder` has the same validation process as the `Labelcoder`. However, it is not without its own challenges:\n",
    "\n",
    "* We want to be able to apply different encoders to features of different dtypes. So it's likely that the same encoder will neither be applied to all columns, nor will all encoders be applied at the same exact time.\n",
    "\n",
    "* Additionally, even within the same dtype (e.g. float/ continuous), different distributions call for different encoders.\n",
    "\n",
    "* Commonly used encoders such a `OneHotEncoder` can ouput multiple columns from a single column input. Therefore, the structure of the features columns is not fixed during encoding.\n",
    "\n",
    "* And finally, throughout this entire process, we need to avoid data leakage.\n",
    "\n",
    "For these reasons, `Featurecoder`'s are applied sequentially; in an ordered chain, one after the other. After an encoder is applied, its columns are removed from the raw featureset and placed into an intermediary cache specific to each split/ fold. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> Right now, `Featurecoder` cannot be created for `Dataset.Image.Featureset`. I'm not opposed to changing this, but I would just have to account for 3D arrays."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Filtering feature columns"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The filtering mode is either:\n",
    "* Inclusive (`include=True`) encode columns that match the filter.\n",
    "* Exclusive (`include=False`) encode columns outside of the filter.\n",
    "\n",
    "Then you can select:\n",
    "1. An optional list of `dtypes`.\n",
    "2. An optional list of `columns` name.\n",
    "  * The column filter is applied after the dtype filter. \n",
    "  \n",
    "> You can create a filter for all columns by setting `include=False` and then seting both `dtypes` and `columns` to `None`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "After submitting your encoder, if `verbose=True` is enabled:\n",
    "* The validation rules help determine why it may have failed.\n",
    "* The print statements help determine which columns your current filter matched, and which raw columns remain. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "featurecoder = encoderset.make_featurecoder(\n",
    "    sklearn_preprocess = PowerTransformer(method='yeo-johnson', copy=False)\n",
    "    , include = True\n",
    "    , dtypes = ['float64']\n",
    "    , columns = None\n",
    "    , verbose = True\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can also view this information via the following attributes: `matching_columns`, `leftover_dtypes`, and `leftover_columns`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. Create an `Algorithm` aka model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ORM"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that our data has been prepared, we transition to the other half of the ORM where the focus is the logic that will be applied to that data."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> An `Algorithm` is the ORM's codename for a machine learning model since *Model* is the most important *reserved word* for ORMs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following attributes tell AIQC how to handle the Algorithm behind the scenes:\n",
    "* `library` - right now, only 'keras' is supported.\n",
    "  * Each library's model object and callbacks (history, early stopping) need to be handled differently.\n",
    "  \n",
    "  \n",
    "* `analysis_type` - right now, these types are supported:\n",
    "  * `'classification_multi'`, `'classification_binary'`, `'regression'`.\n",
    "  * Used to determine which performance metrics to run.\n",
    "  * Must be compatible with the type of label fed to it."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model Definition"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `Algorithm` is composed of the functions:\n",
    "* `function_model_build`.\n",
    "* `function_model_train`.\n",
    "* `function_model_evaluate` (optional, inferred by `analyis_type`). \n",
    "* `function_model_predict` (optional, inferred by `analyis_type`).\n",
    "\n",
    "> May provide overridable defaults for build and train in the future."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can name the functions whatever you want, but do not change the predetermined arguments (e.g. `input_shape`,`**hyperparameters`, `model`, etc.).\n",
    "\n",
    "As we define these functions, we'll see that we can pass *hyperparameters* into these function like so: `hyperparameters['<some_variable_name>']` using the `**hyperparameters` kwarg. Later, we'll provide a list of values for each entry in the hyperparameters dictionary."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's import the modules that we need."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "import keras\n",
    "from keras import metrics\n",
    "from keras.models import Sequential\n",
    "from keras.callbacks import History\n",
    "from keras.layers import Dense, Dropout"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> Later, when running your `Job`'s, if you receive a \"module not found\" error, then you can try troubleshooting by importing that module directly within the function where it is used."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Function to build model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you normally don't wrap the building of your model in a function, don't be scared, all you have to do is add `return model` to the bottom of it, and AIQC will handle the rest. Also, if using `hyperparameters` feels intimidating, you can skip them."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The automatically provided `features_shape` and `label_shape` are handy because:\n",
    "* The number of feature/ label columns is mutable due to encoders (e.g. OHE). \n",
    "* Shapes can be less obvious in multi-dimensional scenarios like colored images."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> You can customize the metrics if you so desire (e.g. change the loss or accuracy), but they will only be applied to the training process/ `History` callback. We'll see later that AIQC will calculate metrics for you automatically."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_build(features_shape, label_shape, **hyperparameters):\n",
    "    \n",
    "\tmodel = Sequential()\n",
    "\tmodel.add(Dense(hyperparameters['neuron_count'], input_shape=features_shape, activation='relu', kernel_initializer='he_uniform'))\n",
    "\tmodel.add(Dropout(0.2))\n",
    "\tmodel.add(Dense(hyperparameters['neuron_count'], activation='relu', kernel_initializer='he_uniform'))\n",
    "    model.add(Dense(input_shape=label_shape, activation='softmax'))\n",
    "\n",
    "\topt = keras.optimizers.Adamax(hyperparameters['learning_rate'])\n",
    "\tmodel.compile(\n",
    "\t\tloss = 'categorical_crossentropy'\n",
    "\t\t, optimizer = opt\n",
    "\t\t, metrics = ['accuracy']\n",
    "\t)\n",
    "\treturn model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Function to train model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `samples_train` - the appropriate data will be fed into the training cycle. For example, `Foldset.samples[fold_index]['folds_train_combined']` or `Splitset.samples['train']`.\n",
    "\n",
    "* `samples_evaluate` - the appropriate data is made available for evaluation. For example, `Foldset.samples[fold_index]['fold_validation']`, `Splitset.samples['validation']`, or `Splitset.samples['test']`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_train(model, samples_train, samples_evaluate, **hyperparameters):\n",
    "    \n",
    "\tmodel.fit(\n",
    "\t\tsamples_train[\"features\"]\n",
    "\t\t, samples_train[\"labels\"]\n",
    "\t\t, validation_data = (\n",
    "\t\t\tsamples_evaluate[\"features\"]\n",
    "\t\t\t, samples_evaluate[\"labels\"]\n",
    "\t\t)\n",
    "\t\t, verbose = 0\n",
    "\t\t, batch_size = 3\n",
    "\t\t, epochs = hyperparameters['epoch_count']\n",
    "\t\t, callbacks=[History()]\n",
    "\t)\n",
    "    \n",
    "\treturn model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Optional, callback to stop training early."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*Early stopping* isn't just about efficiency in reducing the number of `epochs`. If you've specified 300 epochs, there's a chance your model catches on to the underlying patterns early, say around 75-125 epochs. At this point, there's also good chance what it learns in the remaining epochs will cause it to overfit on patterns that are specific to the training data, and thereby and lose it's simplicity/ generalizability.\n",
    "\n",
    "> The `val_` prefix refers to the evaluation samples.\n",
    ">\n",
    "> Remember, regression does not have accuracy metrics.\n",
    ">\n",
    "> `TrainingCallback.Keras.MetricCutoff` is a custom class we wrote to make multi-metric cutoffs easier, so you won't find information about it in the official Keras documentation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_train(model, samples_train, samples_evaluate, **hyperparameters):\n",
    "    # Define one or more metrics to monitor.\n",
    "    metrics_cuttoffs = [\n",
    "        {\"metric\":\"val_accuracy\", \"cutoff\":0.9, \"above_or_below\":\"above\"},\n",
    "        {\"metric\":\"val_loss\", \"cutoff\":0.2, \"above_or_below\":\"below\"}\n",
    "    ]\n",
    "    cutoffs = aiqc.TrainingCallback.Keras.MetricCutoff(metrics_cuttoffs)\n",
    "    # Remember to append `cutoffs` to the list of callbacks.\n",
    "    callbacks=[History(), cutoffs]\n",
    "    \n",
    "    # No changes here.\n",
    "\tmodel.fit(\n",
    "\t\tsamples_train[\"features\"]\n",
    "\t\t, samples_train[\"labels\"]\n",
    "\t\t, validation_data = (\n",
    "\t\t\tsamples_evaluate[\"features\"]\n",
    "\t\t\t, samples_evaluate[\"labels\"]\n",
    "\t\t)\n",
    "\t\t, verbose = 0\n",
    "\t\t, batch_size = 3\n",
    "\t\t, epochs = hyperparameters['epoch_count']\n",
    "\t\t, callbacks = callbacks\n",
    "\t)\n",
    "    \n",
    "\treturn model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Optional, function to predict samples"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`function_model_predict` will be generated for you automatically if set to `None`. The `analysis_type` and `library` of the Algorithm help determine how to handle the predictions."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### a) Regression default."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_predict(model, samples_predict):\n",
    "    predictions = model.predict(samples_predict['features'])\n",
    "    return predictions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### b) Classification binary default."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "All classification `predictions`, both mutliclass and binary, must be returned in ordinal format. \n",
    "\n",
    "> For most libraries, classification algorithms output *probabilities* as opposed to actual predictions when running `model.predict()`. We want to return both of these object `predictions, probabilities` (the order matters) to generate performance metrics behind the scenes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_predict(model, samples_predict):\n",
    "    probabilities = model.predict(samples_predict['features'])\n",
    "    # This is the official keras replacement for binary classes `.predict_classes()`\n",
    "    # It returns one array per sample: `[[0][1][0][1]]` \n",
    "    predictions = (probabilities > 0.5).astype(\"int32\")\n",
    "    \n",
    "    return predictions, probabilities"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### c) Classification multiclass default."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_predict(model, samples_predict):\n",
    "    import numpy as np\n",
    "    probabilities = model.predict(samples_predict['features'])\n",
    "    # This is the official keras replacement for multiclass `.predict_classes()`\n",
    "    # It returns one ordinal array per sample: `[[0][2][1][2]]` \n",
    "    predictions = np.argmax(probabilities, axis=-1)\n",
    "    \n",
    "    return predictions, probabilities"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Optional, function to calculate loss"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When creating an `Algorithm`, the evaluate function will be generated for you automatically if set to `None`. The `analysis_type` and `library` of the Algorithm help determine how to handle the predictions."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The only trick thing here is when `keras.metrics` returns multiple metrics, like *accuracy* and/ or *R^2*. All we are after in this case is the loss for the split/ fold in question."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "def function_model_loss(model, samples_evaluate):\n",
    "    metrics = model.evaluate(samples_evaluate['features'], samples_evaluate['labels'], verbose=0)\n",
    "    if (isinstance(metrics, list)):\n",
    "        loss = metrics[0]\n",
    "    elif (isinstance(metrics, float)):\n",
    "        loss = metrics\n",
    "    else:\n",
    "        raise ValueError(f\"\\nYikes - The 'metrics' returned are neither a list nor a float:\\n{metrics}\\n\")\n",
    "    return loss"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> In contrast to openly specifying a loss function, for example `keras.losses.<loss_fn>()`, the use of `.evaluate()` is consistent because it comes from the compiled model. Also, although `model.compiled_loss` would be more efficient, it requires making encoded `y_true` and `y_pred` available to the user, whereas `.evaluate()` can be called with the same arugments as the other `function_model_*` and many deep learning libraries support this approach. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Group the functions together in an `Algorithm`!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "algorithm = aiqc.Algorithm.make(\n",
    "    library = \"keras\"\n",
    "\t, analysis_type = \"classification_multi\"\n",
    "\t, function_model_build = function_model_build\n",
    "\t, function_model_train = function_model_train\n",
    "\t, function_model_predict = function_model_predict\n",
    "\t, function_model_loss = function_model_loss\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> <!> Remember to use `make` and not `create`. Deceptively,  `create` runs because it is a standard, built-in ORM method. However, it does so without any validation logic."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. Optional, associate a `Hyperparamset` with your model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `hyperparameters` below will be automatically fed into the functions above as `**kwargs` via the `**hyperparameters` argument we saw earlier.\n",
    "\n",
    "For example, wherever you see `hyperparameters['neuron_count']`, it will pull from the *key:value* pair `\"neuron_count\": [9, 12]` seen below. Where \"model A\" would have 9 neurons and \"model B\" would have 12 neurons."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "hyperparameters = {\n",
    "\t\"neuron_count\": [9, 12]\n",
    "\t, \"epoch_count\": [30, 60]\n",
    "    , \"learning_rate\": [0.01, 0.03]\n",
    "}\n",
    "\n",
    "hyperparamset = aiqc.Hyperparamset.from_algorithm(\n",
    "\talgorithm_id = algorithm.id\n",
    "\t, hyperparameters = hyperparameters\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> The number of unique combinations escalates quickly, so in the future, we will provide different strategies for generating and selecting parameters to experiment with. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### `Hyperparamcombo` objects."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each unique combination of hyperparameters is recorded as a `Hyperparamcombo`.\n",
    "\n",
    "Ultimately, a training `Job` will be constructed for each unique combinanation of hyperparameters aka `Hyperparamcombo`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "8"
      ]
     },
     "execution_count": 70,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hyperparamset.hyperparamcombo_count"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'neuron_count': 9, 'epoch_count': 30, 'learning_rate': 0.03}\n",
      "{'neuron_count': 9, 'epoch_count': 30, 'learning_rate': 0.05}\n",
      "{'neuron_count': 9, 'epoch_count': 60, 'learning_rate': 0.03}\n",
      "{'neuron_count': 9, 'epoch_count': 60, 'learning_rate': 0.05}\n",
      "{'neuron_count': 12, 'epoch_count': 30, 'learning_rate': 0.03}\n",
      "{'neuron_count': 12, 'epoch_count': 30, 'learning_rate': 0.05}\n",
      "{'neuron_count': 12, 'epoch_count': 60, 'learning_rate': 0.03}\n",
      "{'neuron_count': 12, 'epoch_count': 60, 'learning_rate': 0.05}\n"
     ]
    }
   ],
   "source": [
    "hyperparamcombos = hyperparamset.hyperparamcombos\n",
    "\n",
    "for h in hyperparamcombos:\n",
    "    print(h.hyperparameters)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. Create a `Batch` of training `Jobs`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The `Batch` is the central object of the \"logic side\" of the ORM. It ties together everything we need for training and hyperparameter tuning."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "batch = aiqc.Batch.from_algorithm(\n",
    "\talgorithm_id = algorithm.id\n",
    "\t, splitset_id = splitset.id\n",
    "\t, hyperparamset_id = hyperparamset.id # Optional.\n",
    "\t, foldset_id = None # Optional.\n",
    "\t, encoderset_id = encoderset.id # Optional.\n",
    "    , repeat_count = 3\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `repeat_count:int` allows us to run the same `Job` multiple times. Normally, each `Job` has 1 `Result` object associated with it upon completion. However, when `repeat_count` is used, a single `Job` will have multiple `Results`.\n",
    "\n",
    "> Due to the fact that training is a *nondeterministic* process, we are likely to get different results each time we train a model, even if we use the same set of parameters. Perhaps you've have the right topology and parameters, but, this time around, the model just didn't recgonize the patterns. Similar to flipping a coin, there is a degree of chance in it, but the real trend averages out upon repetition. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* `hide_test:bool` excludes the test split from the performance metrics and visualizations. This avoids data leakage by forcing the user to make decisions based on the performance on their model on the training and evaluation samples."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### `Job` objects."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each `Job` in the Batch represents a `Hyperparamcombo` that needs to be trained.\n",
    "\n",
    "> If a `Foldset` is used during `Batch` creation, then (a) the number of jobs is multiplied by the `hyperparamcombo_count` and the `fold_count`, (b) each Job will have a `Fold`. Additionally, a superficial `Jobset` will be used to keep track of all Jobs related to that Foldset.\n",
    "\n",
    "`Job.status` keeps track of the execution phase: \"Not yet started\", \"Queued\", or \"Succeeded\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Not yet started'"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "batch.jobs[0].status"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{17: 'Not yet started',\n",
       " 18: 'Not yet started',\n",
       " 19: 'Not yet started',\n",
       " 20: 'Not yet started',\n",
       " 21: 'Not yet started',\n",
       " 22: 'Not yet started',\n",
       " 23: 'Not yet started',\n",
       " 24: 'Not yet started'}"
      ]
     },
     "execution_count": 81,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "batch.get_statuses()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Execute all `Jobs`.\n",
    "The Job queue is asynchronously executed as a background multi-process, so that you can continue to write code on the main process. You can poll the Job `status` as seen above, but there will be a progress bar that updates after each model is done training."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "🔮 Training Models 🔮:  25%|██████████▌                               | 2/8 [00:04<00:12,  2.14s/it]"
     ]
    }
   ],
   "source": [
    "batch.run_jobs()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The queue is interuptable. You can stop the execution of a batch and resume it later.\n",
    "\n",
    "> This also comes in handy if either your machine or Python kernel either crash or are accidentally interupted. During stress tests, I observed that sometimes when running multiple batches at the same time, the SQLite database would lock against one process due to simultaneous writes. Whatever the reason, rest easy, just `run_jobs()` again to pick up where you left off!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Just giving the batch some time to actually start in this notebook.\n",
    "from time import sleep\n",
    "sleep(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Killed `multiprocessing.Process` 'aiqc_batch_3' spawned from Batch <id:3>\n",
      "\n"
     ]
    }
   ],
   "source": [
    "batch.stop_jobs()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{17: 'Succeeded',\n",
       " 18: 'Succeeded',\n",
       " 19: 'Queued',\n",
       " 20: 'Queued',\n",
       " 21: 'Queued',\n",
       " 22: 'Queued',\n",
       " 23: 'Queued',\n",
       " 24: 'Queued'}"
      ]
     },
     "execution_count": 84,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "batch.get_statuses()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Resuming jobs...\n",
      "\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "🔮 Training Models 🔮: 100%|██████████████████████████████████████████| 8/8 [00:16<00:00,  2.12s/it]\n"
     ]
    }
   ],
   "source": [
    "batch.run_jobs()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 10. Assess the `Results`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each `Job` has a `Result`. The following attributes are automatically written to the `Result` after training.\n",
    "    \n",
    "* `model_file`: HDF5 bytes of the model.\n",
    "* `history`: per epoch metrics recorded during training.\n",
    "* `predictions`: dictionary of predictions per split/ fold.\n",
    "* `probabilities`: dictionary of prediction probabilities per split/ fold.\n",
    "* `metrics`: dictionary of single-value metrics depending on the analysis_type.\n",
    "* `plot_data`: metrics readily formatted for plotting."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> The dictionary attributes use split/ fold-based keys."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> For more information of visualization of performance metrics, reference the **Visualization & Metrics** documentation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fetching the trained model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tensorflow.python.keras.engine.sequential.Sequential at 0x14e639250>"
      ]
     },
     "execution_count": 90,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "compiled_model = batch.jobs[0].results[0].get_model()\n",
    "compiled_model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fetching metrics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'test': {'roc_auc': 0.9933333333333333,\n",
       "  'accuracy': 0.9666666666666667,\n",
       "  'precision': 0.9696969696969696,\n",
       "  'recall': 0.9666666666666667,\n",
       "  'f1': 0.9665831244778613,\n",
       "  'loss': 0.10969173908233643},\n",
       " 'validation': {'roc_auc': 1.0,\n",
       "  'accuracy': 0.9444444444444444,\n",
       "  'precision': 0.9523809523809523,\n",
       "  'recall': 0.9444444444444444,\n",
       "  'f1': 0.9440559440559441,\n",
       "  'loss': 0.09142466634511948},\n",
       " 'train': {'roc_auc': 0.9988465974625144,\n",
       "  'accuracy': 0.9705882352941176,\n",
       "  'precision': 0.9708513708513707,\n",
       "  'recall': 0.9705882352941176,\n",
       "  'f1': 0.9705818732424834,\n",
       "  'loss': 0.06465762108564377}}"
      ]
     },
     "execution_count": 92,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "batch.jobs[0].results[0].metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 11. Metrics & Visualization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For more information on visualization of performance metrics, reference the [Visualization & Metrics](visualization.html) documentation."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
